[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "data_pirate blog",
    "section": "",
    "text": "How R’s map2 function works\n\n\n\n\n\n\n\ndata\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nHow to sample from groups where n varies by group\n\n\n\n\n\n\n\npurr\n\n\nR\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nHow str_detect in R works\n\n\n\n\n\n\n\ndata\n\n\nR\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/mutating join/index.html",
    "href": "posts/mutating join/index.html",
    "title": "How R’s map2 function works",
    "section": "",
    "text": "The map2() function in the purrr package of R is used to apply a function to elements of two or more vectors or lists in a pairwise fashion. It iterates over the corresponding elements of the input vectors/lists and returns a new list with the output of applying the specified function to each pair of elements.\nThe basic syntax for map2() is as follows:\n\n#map2(.x, .y, .f, ...)\n\nwhere:\n\n.x, .y: input vectors or lists to iterate over.\n.f: function to apply to each pair of elements from .x and .y. This can be a function name or a lambda function defined inline with the formula syntax (~).\n...: additional arguments to pass to .f.\n\nFor example, let’s say we have two vectors x and y containing numbers, and we want to calculate the sum of the corresponding elements. We can use map2() as follows:\n\nlibrary(purrr)\n\nx <- c(1, 2, 3)\ny <- c(4, 5, 6)\n\nsums <- map2(x, y, ~ .x + .y)\n\nsums\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 7\n\n[[3]]\n[1] 9\n\n# Output: [1] 5 7 9\n\nHere, the lambda function ~ .x + .y takes two arguments (.x and .y) and returns their sum. map2() applies this function to each pair of elements from x and y, and returns a list with the sums."
  },
  {
    "objectID": "posts/Purr tutorial - Jenny Bryan/index.html",
    "href": "posts/Purr tutorial - Jenny Bryan/index.html",
    "title": "How to sample from groups where n varies by group",
    "section": "",
    "text": "Sample from groups, n varies by group\nRef: Article by Jenny Bryan\nThe R code provided below performs the following operations:\n\niris data frame is loaded (if not already loaded). The iris data frame is a built-in data frame in R, which contains measurements of the sepal length, sepal width, petal length, and petal width of three species of iris flowers (Setosa, Versicolor, and Virginica).\nThe group_by function from the dplyr package is used to group the iris data frame by the Species column. This means that all rows with the same Species value are grouped together.\nThe nest function from the tidyr package is used to create a new data frame where the data for each group is contained in a nested data frame column. This means that the resulting data frame will have one row per unique Species value, and each row will have a nested data frame column containing the data for that Species.\nThe ungroup function is used to remove the grouping from the data frame.\nThe mutate function is used to add a new column n to the data frame, which contains the values 2, 5, and 3. These values are recycled to match the number of rows in the data frame. The resulting data frame will have a new column n with these values.\n\n\nsuppressMessages(library(dplyr))\nlibrary(purrr)\nlibrary(tidyr)\nset.seed(4561)\n\n(nested_iris <- iris %>%\n    group_by(Species) %>%   # prep for work by Species\n    nest() %>%              # --> one row per Species\n    ungroup() %>% \n    mutate(n = c(2, 5, 3))) # add sample sizes\n\n# A tibble: 3 × 3\n  Species    data                  n\n  <fct>      <list>            <dbl>\n1 setosa     <tibble [50 × 4]>     2\n2 versicolor <tibble [50 × 4]>     5\n3 virginica  <tibble [50 × 4]>     3\n\n\nOverall, this code (above) is creating a new data frame that groups the iris data by Species, nests the data for each Species in a new column, removes the grouping, and adds a new column n with the values 2, 5, and 3 recycled to match the number of rows in the data frame.\nDraw samples\n\n(sampled_iris <- nested_iris %>%\n  mutate(samp = map2(data, n, sample_n)))\n\n# A tibble: 3 × 4\n  Species    data                  n samp            \n  <fct>      <list>            <dbl> <list>          \n1 setosa     <tibble [50 × 4]>     2 <tibble [2 × 4]>\n2 versicolor <tibble [50 × 4]>     5 <tibble [5 × 4]>\n3 virginica  <tibble [50 × 4]>     3 <tibble [3 × 4]>\n\n\nThe above R code performs the following operations:\n\nnested_iris is a data frame that has been created in previous code, which groups the iris data frame by Species and nests the data for each group in a new column.\nThe map2 function from the purrr package is used to apply a function to each element of two lists in parallel. In this case, the two lists are the data column and the n column of the nested_iris data frame. The data column is the nested data frame for each Species, and the n column contains the values 2, 5, and 3 that were added in the previous code. The sample_n function is used to randomly sample rows from each nested data frame according to the corresponding value in the n column. This means that for each Species, a random sample of rows is taken from the nested data frame.\n\nOverall, this code is taking the nested_iris data frame, and for each Species, it is sampling a random subset of rows from the nested data frame based on the corresponding value in the n column. The resulting data frame sampled_iris has the same structure as nested_iris, but with a new column samp that contains the randomly sampled rows for each Species.\n\nsampled_iris %>% \n  select(-data) %>%\n  unnest(samp)\n\n# A tibble: 10 × 6\n   Species        n Sepal.Length Sepal.Width Petal.Length Petal.Width\n   <fct>      <dbl>        <dbl>       <dbl>        <dbl>       <dbl>\n 1 setosa         2          4.6         3.2          1.4         0.2\n 2 setosa         2          5.1         3.8          1.5         0.3\n 3 versicolor     5          6           3.4          4.5         1.6\n 4 versicolor     5          6           2.2          4           1  \n 5 versicolor     5          5.7         2.8          4.5         1.3\n 6 versicolor     5          6.9         3.1          4.9         1.5\n 7 versicolor     5          7           3.2          4.7         1.4\n 8 virginica      3          5.8         2.7          5.1         1.9\n 9 virginica      3          5.8         2.7          5.1         1.9\n10 virginica      3          6.3         2.9          5.6         1.8\n\n\nLast step:\n\nUnnest, which essentially rowbinds the data frames in samp and replicates Species as necessary."
  },
  {
    "objectID": "posts/str_detect/index.html",
    "href": "posts/str_detect/index.html",
    "title": "How str_detect in R works",
    "section": "",
    "text": "Here’s an example dataset and code that demonstrates how the str_detect function in R works:\n\n# Load the stringr package, which contains the str_detect function\nlibrary(stringr)\n\n# Create a sample dataset\nfruits <- c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\")\n\n# Use str_detect to check if each element in the fruits vector contains the letter \"a\"\nhas_a <- str_detect(fruits, \"a\")\n\n# Print the results\nhas_a\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n\n\nThis code first loads the stringr package, which contains the str_detect function. We then create a sample dataset called fruits that contains five strings representing different types of fruit.\nWe then use the str_detect function to check if each element in the fruits vector contains the letter “a”. The str_detect function takes two arguments: the first is the vector of strings to search, and the second is the pattern to search for. In this case, we use the pattern \"a\", which matches any string that contains the letter “a”.\nThe result of the str_detect function is a logical vector indicating whether each element in the fruits vector contains the pattern. In this case, the has_a vector contains the values TRUE, TRUE, TRUE, TRUE, and FALSE, because the first four elements of fruits contain the letter “a” and the last element does not.\nYou can also use regular expressions to search for more complex patterns using str_detect. For example, if you wanted to find all fruits that start with the letter “a” or “b”, you could use the following code:\n\n# Use str_detect to check if each element in the fruits vector starts with \"a\" or \"b\"\nstarts_with_a_or_b <- str_detect(fruits, \"^(a|b)\")\n\n# Print the results\nstarts_with_a_or_b\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\n\nIn this case, we use the regular expression \"^(a|b)\", which matches any string that starts with either the letter “a” or the letter “b”. The resulting starts_with_a_or_b vector contains the values TRUE, TRUE, FALSE, FALSE, and FALSE, because the first two elements of fruits start with either “a” or “b” and the remaining elements do not.\n\nBackground\nstringr is a package in R that provides a suite of functions for working with strings. It builds on top of the base R string functions (like substr, grep, and gsub) to provide a more consistent and user-friendly set of tools.\nHere are some of the key features of stringr:\n\nConsistent function names: All of the functions in stringr follow the same naming convention (str_ followed by the function name), which makes them easy to remember and use.\nSupport for regular expressions: Many of the stringr functions, including str_detect, str_extract, and str_replace, support regular expressions. This allows you to search for patterns in strings that are more complex than simple substrings.\nVectorized operations: stringr functions are designed to work with vectors of strings, which means you can apply them to an entire column of a data frame or a character vector without needing to use a loop.\nMore intuitive behavior: stringr functions are designed to have more intuitive behavior than their base R counterparts. For example, str_split returns a list of character vectors, rather than a matrix, which makes it easier to work with.\n\nHere are some examples of other stringr functions and what they do:\n\nstr_trim: Removes leading and trailing whitespace from a string.\nstr_to_upper / str_to_lower: Converts a string to upper or lower case, respectively.\nstr_replace_all: Replaces all instances of a pattern with a replacement string.\nstr_sub: Extracts a substring from a string based on its position or a regular expression pattern.\n\nOverall, stringr can be a very useful package for working with strings in R, particularly if you need to perform complex operations involving regular expressions or manipulate large vectors of strings efficiently."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  }
]