[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "data_pirate blog",
    "section": "",
    "text": "Shiny for data visualization in modern day organization\n\n\n\n\n\n\n\ndata\n\n\nShiny\n\n\nviz\n\n\n\n\n\n\n\n\n\n\n\nMar 6, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nPortfolio blog\n\n\n\n\n\n\n\ndata\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nHow to sample from groups where n varies by group\n\n\n\n\n\n\n\npurr\n\n\nR\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nRandom samples based on a set of conditions\n\n\n\n\n\n\n\npurr\n\n\nR\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nHow str_detect in R works\n\n\n\n\n\n\n\ndata\n\n\nR\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nPhilip Kimani\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 2, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/mutating join/index.html",
    "href": "posts/mutating join/index.html",
    "title": "Portfolio blog",
    "section": "",
    "text": "The map2() function in the purrr package of R is used to apply a function to elements of two or more vectors or lists in a pairwise fashion. It iterates over the corresponding elements of the input vectors/lists and returns a new list with the output of applying the specified function to each pair of elements.\nThe basic syntax for map2() is as follows:\n\n#map2(.x, .y, .f, ...)\n\nwhere:\n\n.x, .y: input vectors or lists to iterate over.\n.f: function to apply to each pair of elements from .x and .y. This can be a function name or a lambda function defined inline with the formula syntax (~).\n...: additional arguments to pass to .f.\n\nFor example, let’s say we have two vectors x and y containing numbers, and we want to calculate the sum of the corresponding elements. We can use map2() as follows:\n\nlibrary(purrr)\n\nx <- c(1, 2, 3)\ny <- c(4, 5, 6)\n\nsums <- map2(x, y, ~ .x + .y)\n\nsums\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 7\n\n[[3]]\n[1] 9\n\n# Output: [1] 5 7 9\n\nHere, the lambda function ~ .x + .y takes two arguments (.x and .y) and returns their sum. map2() applies this function to each pair of elements from x and y, and returns a list with the sums."
  },
  {
    "objectID": "posts/Purr tutorial - Jenny Bryan/index.html",
    "href": "posts/Purr tutorial - Jenny Bryan/index.html",
    "title": "How to sample from groups where n varies by group",
    "section": "",
    "text": "Sample from groups, n varies by group\nRef: Article by Jenny Bryan\nThe R code provided below performs the following operations:\n\niris data frame is loaded (if not already loaded). The iris data frame is a built-in data frame in R, which contains measurements of the sepal length, sepal width, petal length, and petal width of three species of iris flowers (Setosa, Versicolor, and Virginica).\nThe group_by function from the dplyr package is used to group the iris data frame by the Species column. ## This means that all rows with the same Species value are grouped together.\nThe nest function from the tidyr package is used to create a new data frame where the data for each group is contained in a nested data frame column. This means that the resulting data frame will have one row per unique Species value, and each row will have a nested data frame column containing the data for that Species.\nThe ungroup function is used to remove the grouping from the data frame.\nThe mutate function is used to add a new column n to the data frame, which contains the values 2, 5, and 3. These values are recycled to match the number of rows in the data frame. The resulting data frame will have a new column n with these values.\n\n\nsuppressMessages(library(dplyr))\nlibrary(purrr)\nlibrary(tidyr)\nset.seed(4561)\n\n(nested_iris <- iris %>%\n    group_by(Species) %>%   # prep for work by Species\n    nest() %>%              # --> one row per Species\n    ungroup() %>% \n    mutate(n = c(2, 5, 3))) # add sample sizes\n\n# A tibble: 3 × 3\n  Species    data                  n\n  <fct>      <list>            <dbl>\n1 setosa     <tibble [50 × 4]>     2\n2 versicolor <tibble [50 × 4]>     5\n3 virginica  <tibble [50 × 4]>     3\n\n\nOverall, this code (above) is creating a new data frame that groups the iris data by Species, nests the data for each Species in a new column, removes the grouping, and adds a new column n with the values 2, 5, and 3 recycled to match the number of rows in the data frame.\nDraw samples\n\n(sampled_iris <- nested_iris %>%\n  mutate(samp = map2(data, n, sample_n)))\n\n# A tibble: 3 × 4\n  Species    data                  n samp            \n  <fct>      <list>            <dbl> <list>          \n1 setosa     <tibble [50 × 4]>     2 <tibble [2 × 4]>\n2 versicolor <tibble [50 × 4]>     5 <tibble [5 × 4]>\n3 virginica  <tibble [50 × 4]>     3 <tibble [3 × 4]>\n\n\nThe above R code performs the following operations:\n\nnested_iris is a data frame that has been created in previous code, which groups the iris data frame by Species and nests the data for each group in a new column.\nThe map2 function from the purrr package is used to apply a function to each element of two lists in parallel. In this case, the two lists are the data column and the n column of the nested_iris data frame. The data column is the nested data frame for each Species, and the n column contains the values 2, 5, and 3 that were added in the previous code. The sample_n function is used to randomly sample rows from each nested data frame according to the corresponding value in the n column. This means that for each Species, a random sample of rows is taken from the nested data frame.\n\nOverall, this code is taking the nested_iris data frame, and for each Species, it is sampling a random subset of rows from the nested data frame based on the corresponding value in the n column. The resulting data frame sampled_iris has the same structure as nested_iris, but with a new column samp that contains the randomly sampled rows for each Species.\n\nsampled_iris %>% \n  select(-data) %>%\n  unnest(samp)\n\n# A tibble: 10 × 6\n   Species        n Sepal.Length Sepal.Width Petal.Length Petal.Width\n   <fct>      <dbl>        <dbl>       <dbl>        <dbl>       <dbl>\n 1 setosa         2          4.6         3.2          1.4         0.2\n 2 setosa         2          5.1         3.8          1.5         0.3\n 3 versicolor     5          6           3.4          4.5         1.6\n 4 versicolor     5          6           2.2          4           1  \n 5 versicolor     5          5.7         2.8          4.5         1.3\n 6 versicolor     5          6.9         3.1          4.9         1.5\n 7 versicolor     5          7           3.2          4.7         1.4\n 8 virginica      3          5.8         2.7          5.1         1.9\n 9 virginica      3          5.8         2.7          5.1         1.9\n10 virginica      3          6.3         2.9          5.6         1.8\n\n\nLast step:\n\nUnnest, which essentially rowbinds the data frames in samp and replicates Species as necessary."
  },
  {
    "objectID": "posts/Sampling data iteratively with multiple conditions/index.html",
    "href": "posts/Sampling data iteratively with multiple conditions/index.html",
    "title": "Random samples based on a set of conditions",
    "section": "",
    "text": "Sample data based on conditions (separate dataframe)\nI have shared this post here as I would to develop the solution further over time and potentially develop a package out of that in future.\n\nsuppressMessages(library(tidyverse))\n\nfrst <- tibble::tribble(\n  ~business.name, ~product.type, ~quantity.sold,\n             \"A\",           \"x\",             3L,\n             \"B\",           \"y\",             5L,\n             \"C\",           \"z\",             4L,\n             \"C\",           \"x\",             2L\n  )\n\nscnd <- tibble::tribble(\n  ~business.name, ~product.type,       ~SKU,\n             \"A\",           \"x\", 255353845L,\n             \"A\",           \"x\", 255356319L,\n             \"A\",           \"x\", 255362751L,\n             \"A\",           \"x\", 255370204L,\n             \"A\",           \"x\", 255454003L,\n             \"A\",           \"x\", 255458362L,\n             \"A\",           \"x\", 255593042L,\n             \"A\",           \"x\", 255636116L,\n             \"A\",           \"x\", 255717549L,\n             \"B\",           \"y\", 255844018L,\n             \"B\",           \"y\", 255909292L,\n             \"B\",           \"y\", 255915742L,\n             \"B\",           \"y\", 255919530L,\n             \"B\",           \"y\", 255923843L,\n             \"B\",           \"y\", 255933049L,\n             \"B\",           \"y\", 255936045L,\n             \"B\",           \"y\", 255941696L,\n             \"B\",           \"y\", 255946809L,\n             \"B\",           \"y\", 255949532L,\n             \"B\",           \"y\", 255966127L,\n             \"B\",           \"y\", 255997292L,\n             \"C\",           \"z\", 255998831L,\n             \"C\",           \"z\", 256001327L,\n             \"C\",           \"z\", 256003617L,\n             \"C\",           \"z\", 256005181L,\n             \"C\",           \"z\", 256011669L,\n             \"C\",           \"z\", 256013837L,\n             \"C\",           \"z\", 256017545L,\n             \"C\",           \"z\", 256019818L,\n             \"C\",           \"z\", 256036093L,\n             \"C\",           \"z\", 256040208L,\n             \"C\",           \"z\", 256051672L,\n             \"C\",           \"x\", 256138309L,\n             \"C\",           \"x\", 256161535L,\n             \"C\",           \"x\", 256189403L,\n             \"C\",           \"x\", 256227739L,\n             \"C\",           \"x\", 256236233L,\n             \"C\",           \"x\", 256240570L,\n             \"C\",           \"x\", 256245429L,\n             \"C\",           \"x\", 256662283L,\n             \"C\",           \"x\", 256671028L,\n             \"C\",           \"x\", 256672339L,\n             \"C\",           \"x\", 256678241L,\n             \"C\",           \"x\", 256683024L,\n             \"C\",           \"x\", 256718422L,\n             \"C\",           \"x\", 256779953L\n  )\n\n\nmap_dfr(1:nrow(frst), \\(x_){ \n  row <- slice(frst,x_)\n  target <- row$quantity.sold\n  candidates <- row %>%  left_join(scnd,\n                                 multiple=\"all\")\n  \n  candidates_sample <- slice_sample(candidates,\n                                   n = target)\n  candidates_sample\n  })\n\nJoining, by = c(\"business.name\", \"product.type\")\nJoining, by = c(\"business.name\", \"product.type\")\nJoining, by = c(\"business.name\", \"product.type\")\nJoining, by = c(\"business.name\", \"product.type\")\n\n\n# A tibble: 14 × 4\n   business.name product.type quantity.sold       SKU\n   <chr>         <chr>                <int>     <int>\n 1 A             x                        3 255356319\n 2 A             x                        3 255636116\n 3 A             x                        3 255458362\n 4 B             y                        5 255933049\n 5 B             y                        5 255941696\n 6 B             y                        5 255909292\n 7 B             y                        5 255919530\n 8 B             y                        5 255936045\n 9 C             z                        4 256019818\n10 C             z                        4 256036093\n11 C             z                        4 255998831\n12 C             z                        4 256017545\n13 C             x                        2 256671028\n14 C             x                        2 256189403\n\n\nThe given R code uses the map_dfr() function from the purrr package to iterate over each row of a data frame called frst.\nFor each row, the code selects the quantity.sold value and saves it as the target variable. Then, it performs a left join with another data frame called scnd using the left_join() function from the dplyr package. The multiple = \"all\" argument specifies that the join should match all occurrences of the join key.\nThe resulting data frame is then subsetted to a sample of rows with size n = target using the slice_sample() function from the dplyr package. Finally, the function returns the subsetted data frame.\nThe \\(x_) syntax is used to define an anonymous function that takes a single argument x_. In this case, x_ represents the row index of frst being processed by the function. The function body is the set of operations described above.\nThe map_dfr() function combines the results of each iteration into a single data frame, with rows being appended to each other. The resulting data frame will have the same number of columns as the output of the anonymous function, and as many rows as there are in frst.\nRef: Problem I posted a while ago at Rstudion community website (Nir A Graham, 2023)"
  },
  {
    "objectID": "posts/Shiny dashboarding/index.html",
    "href": "posts/Shiny dashboarding/index.html",
    "title": "Shiny for data visualization in modern day organization",
    "section": "",
    "text": "Create and share interactive reports using Shiny apps\nR Shiny is a web application framework used for creating interactive web applications and dashboards.\n\n\n\n\n\nHere are some key benefits of using(Granjon 2022) R Shiny for creating dashboards for an organization:\n1. Easy to Use: R Shiny allows data analysts and statisticians to create interactive dashboards without the need for advanced web development skills. This means that you can focus on the data analysis and visualizations rather than the coding.\n2. Customizable: R Shiny provides a wide range of customization options, allowing you to create dashboards that meet your organization’s specific needs. You can easily add features, such as interactive filters and plots, to your dashboard to provide a more engaging user experience.\n3. Real-time Analytics: R Shiny enables real-time analytics, which means you can update your dashboards with the latest data as soon as it becomes available. This is particularly useful for organizations that require up-to-date information to make informed decisions(Li and Mao 2015).\n4. Interactive Visualization: R Shiny allows you to create interactive visualizations that enable users to explore the data and gain insights quickly. This can help to enhance the understanding of complex data and can lead to better decision-making(Sievert 2020c, 2020b, 2020a).\n5. Cost-effective: R Shiny is an open-source framework, which means it is free to use. This makes it an ideal solution for organizations that want to create interactive dashboards without investing heavily in proprietary software(Kavanagh 2004).\n6. Scalable: R Shiny can handle large datasets and can be used to create dashboards for multiple users. This means that it can be used to create enterprise-level dashboards that can be used across the organization.\nOverall, R Shiny is an excellent tool for creating dashboards for organizations that want to make data-driven decisions. Its ease of use, customization options, real-time analytics, and interactive visualizations make it a powerful solution for creating engaging and informative dashboards.\n(Singh 2020a, 2020b; Sharma and Gupta 2022; Zaman 2020).\nFurther, R Shiny can be a powerful tool in a machine learning context. Its interactivity, visualization, deployment, scalability, and customization options make it an excellent solution for creating machine learning applications that are accessible, informative, and engaging.\n\n\n\n\nReferences\n\nGranjon, David. 2022. “JavaScript for Shiny.” In, 161–86. Chapman; Hall/CRC. https://doi.org/10.1201/9781003124924-10.\n\n\nKavanagh, Paul. 2004. “How Open Source Software Is Developed.” In, 203–19. Elsevier. https://doi.org/10.1016/b978-155558320-0/50010-6.\n\n\nLi, Xiaofang, and Yingchi Mao. 2015. “Real-Time Data ETL Framework for Big Real-Time Data Analysis.” 2015 IEEE International Conference on Information and Automation, August. https://doi.org/10.1109/icinfa.2015.7279485.\n\n\nSharma, Falguni, and Punit Gupta. 2022. “Machine Learning-Based Predictive Model to Improve Cloud Application Performance in Cloud SaaS.” In, 95–118. Chapman; Hall/CRC. https://doi.org/10.1201/9781003185376-6.\n\n\nSievert, Carson. 2020a. “Boxplots.” In, 115–18. Chapman; Hall/CRC. https://doi.org/10.1201/9780429447273-7.\n\n\n———. 2020b. Interactive Web-Based Data Visualization with r, Plotly, and Shiny. Chapman; Hall/CRC. https://doi.org/10.1201/9780429447273.\n\n\n———. 2020c. “Server-Side Linking with Shiny.” In, 239–310. Chapman; Hall/CRC. https://doi.org/10.1201/9780429447273-21.\n\n\nSingh, Pramod. 2020a. “Machine Learning Deployment Using Docker.” In, 91–126. Apress. https://doi.org/10.1007/978-1-4842-6546-8_4.\n\n\n———. 2020b. “Machine Learning Deployment Using Kubernetes.” In, 127–46. Apress. https://doi.org/10.1007/978-1-4842-6546-8_5.\n\n\nZaman, Faisal. 2020. TensorFlow Lite for Mobile Development. Apress. https://doi.org/10.1007/978-1-4842-6666-3."
  },
  {
    "objectID": "posts/str_detect/index.html",
    "href": "posts/str_detect/index.html",
    "title": "How str_detect in R works",
    "section": "",
    "text": "Here’s an example dataset and code that demonstrates how the str_detect function in R works:\n\n# Load the stringr package, which contains the str_detect function\nlibrary(stringr)\n\n# Create a sample dataset\nfruits <- c(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\")\n\n# Use str_detect to check if each element in the fruits vector contains the letter \"a\"\nhas_a <- str_detect(fruits, \"a\")\n\n# Print the results\nhas_a\n\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n\n\nThis code first loads the stringr package, which contains the str_detect function. We then create a sample dataset called fruits that contains five strings representing different types of fruit.\nWe then use the str_detect function to check if each element in the fruits vector contains the letter “a”. The str_detect function takes two arguments: the first is the vector of strings to search, and the second is the pattern to search for. In this case, we use the pattern \"a\", which matches any string that contains the letter “a”.\nThe result of the str_detect function is a logical vector indicating whether each element in the fruits vector contains the pattern. In this case, the has_a vector contains the values TRUE, TRUE, TRUE, TRUE, and FALSE, because the first four elements of fruits contain the letter “a” and the last element does not.\nYou can also use regular expressions to search for more complex patterns using str_detect. For example, if you wanted to find all fruits that start with the letter “a” or “b”, you could use the following code:\n\n# Use str_detect to check if each element in the fruits vector starts with \"a\" or \"b\"\nstarts_with_a_or_b <- str_detect(fruits, \"^(a|b)\")\n\n# Print the results\nstarts_with_a_or_b\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\n\nIn this case, we use the regular expression \"^(a|b)\", which matches any string that starts with either the letter “a” or the letter “b”. The resulting starts_with_a_or_b vector contains the values TRUE, TRUE, FALSE, FALSE, and FALSE, because the first two elements of fruits start with either “a” or “b” and the remaining elements do not.\n\nBackground\nstringr is a package in R that provides a suite of functions for working with strings. It builds on top of the base R string functions (like substr, grep, and gsub) to provide a more consistent and user-friendly set of tools.\nHere are some of the key features of stringr:\n\nConsistent function names: All of the functions in stringr follow the same naming convention (str_ followed by the function name), which makes them easy to remember and use.\nSupport for regular expressions: Many of the stringr functions, including str_detect, str_extract, and str_replace, support regular expressions. This allows you to search for patterns in strings that are more complex than simple substrings.\nVectorized operations: stringr functions are designed to work with vectors of strings, which means you can apply them to an entire column of a data frame or a character vector without needing to use a loop.\nMore intuitive behavior: stringr functions are designed to have more intuitive behavior than their base R counterparts. For example, str_split returns a list of character vectors, rather than a matrix, which makes it easier to work with.\n\nHere are some examples of other stringr functions and what they do:\n\nstr_trim: Removes leading and trailing whitespace from a string.\nstr_to_upper / str_to_lower: Converts a string to upper or lower case, respectively.\nstr_replace_all: Replaces all instances of a pattern with a replacement string.\nstr_sub: Extracts a substring from a string based on its position or a regular expression pattern.\n\nOverall, stringr can be a very useful package for working with strings in R, particularly if you need to perform complex operations involving regular expressions or manipulate large vectors of strings efficiently."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  }
]