{
  "hash": "8f4b8b4b3082b168aa46c6b635601d3c",
  "result": {
    "markdown": "---\ntitle: \"How to sample from groups where n varies by group\"\nauthor: \"Philip Kimani\"\ndate: \"2023-03-05\"\ncategories: [purr, R, Quarto]\nimage: \"logo.png\"\n---\n\n\n# Sample from groups, n varies by group\n\nRef: [Article by Jenny Bryan](https://jennybc.github.io/purrr-tutorial/ls12_different-sized-samples.html \"original purr tutorial\")\n\nThe R code provided below performs the following operations:\n\n1.  **`iris`** data frame is loaded (if not already loaded). The **`iris`** data frame is a built-in data frame in R, which contains measurements of the sepal length, sepal width, petal length, and petal width of three species of iris flowers (Setosa, Versicolor, and Virginica).\n\n2.  The **`group_by`** function from the **`dplyr`** package is used to group the **`iris`** data frame by the **`Species`** column. \\## This means that all rows with the same **`Species`** value are grouped together.\n\n3.  The **`nest`** function from the **`tidyr`** package is used to create a new data frame where the data for each group is contained in a nested data frame column. This means that the resulting data frame will have one row per unique **`Species`** value, and each row will have a nested data frame column containing the data for that **`Species`**.\n\n4.  The **`ungroup`** function is used to remove the grouping from the data frame.\n\n5.  The **`mutate`** function is used to add a new column **`n`** to the data frame, which contains the values **`2`**, **`5`**, and **`3`**. These values are recycled to match the number of rows in the data frame. The resulting data frame will have a new column **`n`** with these values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(library(dplyr))\nlibrary(purrr)\nlibrary(tidyr)\nset.seed(4561)\n\n(nested_iris <- iris %>%\n    group_by(Species) %>%   # prep for work by Species\n    nest() %>%              # --> one row per Species\n    ungroup() %>% \n    mutate(n = c(2, 5, 3))) # add sample sizes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  Species    data                  n\n  <fct>      <list>            <dbl>\n1 setosa     <tibble [50 × 4]>     2\n2 versicolor <tibble [50 × 4]>     5\n3 virginica  <tibble [50 × 4]>     3\n```\n:::\n:::\n\n\nOverall, this code (above) is creating a new data frame that groups the iris data by Species, nests the data for each Species in a new column, removes the grouping, and adds a new column **`n`** with the values 2, 5, and 3 recycled to match the number of rows in the data frame.\n\nDraw samples\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(sampled_iris <- nested_iris %>%\n  mutate(samp = map2(data, n, sample_n)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  Species    data                  n samp            \n  <fct>      <list>            <dbl> <list>          \n1 setosa     <tibble [50 × 4]>     2 <tibble [2 × 4]>\n2 versicolor <tibble [50 × 4]>     5 <tibble [5 × 4]>\n3 virginica  <tibble [50 × 4]>     3 <tibble [3 × 4]>\n```\n:::\n:::\n\n\nThe above R code performs the following operations:\n\n1.  **`nested_iris`** is a data frame that has been created in previous code, which groups the **`iris`** data frame by **`Species`** and nests the data for each group in a new column.\n\n2.  The **`map2`** function from the **`purrr`** package is used to apply a function to each element of two lists in parallel. In this case, the two lists are the **`data`** column and the **`n`** column of the **`nested_iris`** data frame. The **`data`** column is the nested data frame for each **`Species`**, and the **`n`** column contains the values **`2`**, **`5`**, and **`3`** that were added in the previous code. The **`sample_n`** function is used to randomly sample rows from each nested data frame according to the corresponding value in the **`n`** column. This means that for each **`Species`**, a random sample of rows is taken from the nested data frame.\n\nOverall, this code is taking the **`nested_iris`** data frame, and for each **`Species`**, it is sampling a random subset of rows from the nested data frame based on the corresponding value in the **`n`** column. The resulting data frame **`sampled_iris`** has the same structure as **`nested_iris`**, but with a new column **`samp`** that contains the randomly sampled rows for each **`Species`**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsampled_iris %>% \n  select(-data) %>%\n  unnest(samp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 6\n   Species        n Sepal.Length Sepal.Width Petal.Length Petal.Width\n   <fct>      <dbl>        <dbl>       <dbl>        <dbl>       <dbl>\n 1 setosa         2          4.6         3.2          1.4         0.2\n 2 setosa         2          5.1         3.8          1.5         0.3\n 3 versicolor     5          6           3.4          4.5         1.6\n 4 versicolor     5          6           2.2          4           1  \n 5 versicolor     5          5.7         2.8          4.5         1.3\n 6 versicolor     5          6.9         3.1          4.9         1.5\n 7 versicolor     5          7           3.2          4.7         1.4\n 8 virginica      3          5.8         2.7          5.1         1.9\n 9 virginica      3          5.8         2.7          5.1         1.9\n10 virginica      3          6.3         2.9          5.6         1.8\n```\n:::\n:::\n\n\nLast step:\n\n-   Unnest, which essentially rowbinds the data frames in `samp` and replicates `Species` as necessary.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}